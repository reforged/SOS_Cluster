\section{Implementierung}

Um die dargelegten Algorithmen zu testen und zu demonstrieren, haben wir
eine Simulation entwickelt. Im folgenden wird zunächst die gewählte
Entwicklungsplattform vorgestellt und begründet, anschließend werden die
Implementierung des Äthers, der Motes und die Spezifika der
Simulations-Umgebung dargestellt.

\subsection{JavaScript}

Die Simulation ist in JavaScript implementiert; als
Entwicklungsplattform haben wir Webbrowser mit aktueller
JavaScript-Engine (z.B. Googles V8 und Mozillas JägerMonkey) und
Unterstützung für 2D-Grafikdarstellung mithilfe des canvas-Tags gewählt.

Mit JavaScript als dynamisch-typisierte Skriptsprache lassen sich ohne
große Deklartions-Overhead schnell sichtbare Ergebnisse produzieren. Mit
dem neuen HTML5 Canvas Element steht eine einfach zu nutzende
Zeichenfläche zur Verfügung und für alle gängigem Betriebssysteme gibt
es Browser die die Simulation auführen können.

\subsection{Motes}

Die simulierten Motes sind Instanze der Klasse Mote, deren
Implementierung sich über die Dateien mote.js, mote\_member.js und
mote\_head.js erstreckt.

Das in Abschnitt ?? dargestellte Protokoll ist vollständig, aber
zustandslos, in der Klasse Mote implememtiert.

Wird eine neue Mote instanziert, initialisiert der Konstruktur einige
interne Variablen, registriert die neue Mote dann beim Äther und kann
dann gestartet (``eingeschaltet'') werden.

\subsection{Äther}

Die Motes kommunizieren untereinander nur über Nachrichten. Den
(virtuellen) Versandt der Nachrichten übernimmt der simulierte Äther,
implementiert als Singleton ``MoteList'' in der Datei motelist.js.

Ähnlich dem Observer-Entwurfsmuster stellt MoteList eine Methode
``register'' bereit, die neuer Motes aufnimmt. Sie wird vom
Mote-Konstruktur aufgerufen. Zudem gibt es eine Methode ``send'', die
den Versandt von Nachrichten anstößt.

Beim Versandt wird zunächst die Position des Absenders abgerufen,
anschließend wird die Distanz zu allen anderen registrierten Motes
berechnet. Ist die Distanz nicht größer als ein festgelegter
Senderadius, wird die Nachricht zugestellt indem sie der ``onRecv''
Methode der jeweiligen Empfänger-Mote übergeben wird.

\subsection{Grafische Oberfläche}

Die grafische Oberfläche beschränkt sich im wesentlichen auf eine
``Karte'' in der alle Motes, möglichen Verbindungen, sowie Cluster
verzeichnet sind.

Die Zeichenfunktion ist dabei in der MoteList implementiert, da nur
diese Zugriff auf die Positionen der Motes hat.

Die Motes sind als kleine Quadrate auf der Karte dargestellt, oberhalb
eines Cluser-Heads wird jeweils die ID des Clusters angezeigt. Zwischen
Motes die nicht mehr als einen Senderadius voneinander entfernt sind,
ist eine blasse Linie eingezeichnet. Zwischen zwei Motes die zu einem
Cluster gehören, wird diese Linie farblich hervorgehoben.

Weitere Motes werden hinzugefügt, wenn man auf eine freie Fläche der
Karte klickt. Klickt man eine vorhandene Mote an, wird diese entfernt.

Die Rotation der Cluster-Heads wird durch Drücken der Taste 'r'
angestoßen. Die Taste 'a' schaltet eine automatische Rotation der
Cluster-Heads in einem fixen Intervall ein oder aus.
